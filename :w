#include <efi.h>
#include <efilib.h>
#include "efiapi.h"
#include "shared.h"
#include "types.h"

#define PACK __attribute__((packed))

typedef struct PACK {
    char     Signature[8];
    uint8_t  Checksum;
    char     OemId[6];
    uint8_t  Revision;
    uint32_t RsdtAddress;
    uint32_t Length;
    uint64_t XsdtAddress;
    uint8_t  ExtendedChecksum;
    uint8_t  Reserved[3];
} RSDP;

typedef struct PACK {
    char     Signature[4];
    uint32_t Length;
    uint8_t  Revision, Checksum;
    char     OemId[6];
    char     OemTableId[8];
    uint32_t OemRevision, CreatorId, CreatorRevision;
} SDT_HDR;

typedef struct PACK {
    SDT_HDR  Hdr;
    uint64_t Entry[];
} XSDT;

static void dump_bytes(void *addr, UINTN len) {
    UINT8 *p = (UINT8*)addr;
    for (UINTN i = 0; i < len; i += 16) {
        Print(L"%08lx: ", (UINTN)addr + i);
        for (UINTN j = 0; j < 16 && i + j < len; ++j)
            Print(L"%02x ", p[i + j]);
        Print(L"\r\n");
    }
}

static EFI_GRAPHICS_OUTPUT_PROTOCOL *get_gop(void) {
    EFI_GUID gop_guid = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;
    EFI_GRAPHICS_OUTPUT_PROTOCOL *gop;

    uefi_call_wrapper(BS->LocateProtocol, 3, &gop_guid, NULL, (void**)&gop);
    return gop;
}

EFI_FILE_HANDLE get_volume(EFI_HANDLE image) {
    EFI_LOADED_IMAGE_PROTOCOL *loaded_image = NULL;
    EFI_GUID lip_guid = EFI_LOADED_IMAGE_PROTOCOL_GUID;
    EFI_FILE_IO_INTERFACE *io_volume;
    EFI_GUID fsGuid = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;
    EFI_FILE_HANDLE volume;

    uefi_call_wrapper(BS->HandleProtocol, 3, image, &lip_guid, (void **) &loaded_image);
    uefi_call_wrapper(BS->HandleProtocol, 3, loaded_image->DeviceHandle, &fsGuid, (VOID*)&io_volume);
    uefi_call_wrapper(io_volume->OpenVolume, 2, io_volume, &volume);

    return volume;
}

u64 file_size(EFI_FILE_HANDLE file_handle) {
    EFI_FILE_INFO *file_info = LibFileInfo(file_handle);
    u64 size = file_info->FileSize;
    FreePool(file_info);
    return size;
}

EFI_STATUS exit_boot(EFI_HANDLE image) {
    EFI_STATUS st;
    u64 mmap_size = 0, map_key, desc_size;
    u32 desc_ver;

    st = uefi_call_wrapper(BS->GetMemoryMap, 5, &mmap_size, NULL, &map_key, &desc_size, &desc_ver);
    if (st != EFI_BUFFER_TOO_SMALL) return st;

    mmap_size += 2 * desc_size;
    EFI_MEMORY_DESCRIPTOR *mmap = AllocatePool(mmap_size);
    if (!mmap) return EFI_OUT_OF_RESOURCES;

    st = uefi_call_wrapper(BS->GetMemoryMap, 5, &mmap_size, mmap, &map_key, &desc_size, &desc_ver);
    if (EFI_ERROR(st)) return st;

    st = uefi_call_wrapper(BS->ExitBootServices, 2, image, map_key);
    return st;
}

static int checksum_ok(const void *p, UINTN len) {
    const u8 *b = p; u8 s = 0;
    for (u64 i = 0; i < len; i++) s += b[i];
    return s == 0;
}

static void* get_rsdp(EFI_SYSTEM_TABLE* system_table) {
    for (u64 i = 0; i < system_table->NumberOfTableEntries; ++i) {
        EFI_CONFIGURATION_TABLE* t = &system_table->ConfigurationTable[i];

        static EFI_GUID Acpi20Guid = ACPI_20_TABLE_GUID;
        static EFI_GUID AcpiGuid = ACPI_TABLE_GUID;

        if (!CompareGuid(&t->VendorGuid, &Acpi20Guid) && !CompareGuid(&t->VendorGuid, &AcpiGuid)) {
            continue;
        }

        RSDP* rsdp = (RSDP*)t->VendorTable;
        if (rsdp && checksum_ok(rsdp, rsdp->Revision >= 2 ? rsdp->Length : 20)) {
            return rsdp;
        }
    }

    return NULL;
}

static SDT_HDR* find_in_xsdt(XSDT *xsdt, const char sig[4]) {
    if (!xsdt || !checksum_ok(xsdt, xsdt->Hdr.Length)) return NULL;
    u64 n = (xsdt->Hdr.Length - sizeof(SDT_HDR)) / sizeof(uint64_t);
    for (u64 i = 0; i < n; i++) {
        SDT_HDR *h = (SDT_HDR*)(u64)xsdt->Entry[i];
        if (!h) continue;
        if (!CompareMem(h->Signature, sig, 4) && checksum_ok(h, h->Length))
            return h;
    }
    return NULL;
}

BOOLEAN fill_acpi_addrs(EFI_SYSTEM_TABLE *st, acpi *acpi_) {
    RSDP *rsdp = get_rsdp(st);
    if (!rsdp) return FALSE;

    u64 xsdt_pa = (rsdp->Revision >= 2) ? rsdp->XsdtAddress
                                             : (uint64_t)(uint32_t)rsdp->RsdtAddress; /* works: XSDT preferred */
    XSDT *xsdt = (XSDT*)(u64)xsdt_pa;
    SDT_HDR *madt = find_in_xsdt(xsdt, "APIC");
    if (!madt) return FALSE;

    acpi_->rsdp = (u64)(UINTN)rsdp;
    acpi_->xsdt = (u64)(UINTN)xsdt;
    acpi_->madt = (u64)(UINTN)madt;
    return TRUE;
}

EFI_STATUS efi_main(EFI_HANDLE image_handle, EFI_SYSTEM_TABLE *system_table) {
    InitializeLib(image_handle, system_table);
    Print(L"Loading the kernel...\r\n");

    EFI_GRAPHICS_OUTPUT_PROTOCOL *gop = get_gop();
    if (!gop) {
        Print(L"GOP not found\r\n");
        return EFI_UNSUPPORTED;
    }

    framebuffer_info framebuffer;
    framebuffer.base = (void*) gop->Mode->FrameBufferBase;
    framebuffer.width = gop->Mode->Info->HorizontalResolution;
    framebuffer.height = gop->Mode->Info->VerticalResolution;
    framebuffer.pitch = framebuffer.pixels_per_scanline * 4;
    framebuffer.pixels_per_scanline = gop->Mode->Info->PixelsPerScanLine;

    //acpi acpi_data;
    //fill_acpi_addrs(system_table, &acpi_data);

    uefi_data uefi_dt;
    uefi_dt.fb = &framebuffer;
    uefi_dt.acpi_data = NULL;



    uint32_t *base = (uint32_t*)framebuffer.base;
    for (int i = 0; i < 100000; ++i) {
        base[i] = 0xFF00FF00;
    }

    EFI_FILE_HANDLE volume = get_volume(image_handle);
    CHAR16 *kernel_file_name = L"kernel.bin";
    EFI_FILE_HANDLE kernel_handle;

    uefi_call_wrapper(volume->Open, 5, volume, &kernel_handle, kernel_file_name, EFI_FILE_MODE_READ, EFI_FILE_READ_ONLY | EFI_FILE_HIDDEN | EFI_FILE_SYSTEM);

    UINT64 kernel_size = file_size(kernel_handle);
    UINT8  *buffer     = AllocatePool(kernel_size);

    uefi_call_wrapper(kernel_handle->Read, 3, kernel_handle, &kernel_size, buffer);
    uefi_call_wrapper(kernel_handle->Close, 1, kernel_handle);

    EFI_PHYSICAL_ADDRESS phys = 0x100000;
    UINTN pages = (UINTN)((kernel_size + 0xFFF) >> 12); // add 4095 and dividde by 4096 to get the number of pages
    EFI_STATUS st_alloc = uefi_call_wrapper(BS->AllocatePages, 4,
                        AllocateAddress, EfiLoaderData, pages, &phys);

    if (EFI_ERROR(st_alloc)) {
        Print(L"AllocatePages at 0x100000 failed: %r\r\n", st_alloc);
        return st_alloc;
    }

    uefi_call_wrapper(BS->CopyMem, 3, (VOID*)(UINTN)phys, buffer, (UINTN)kernel_size);
    FreePool(buffer);

    uefi_call_wrapper(volume->Close, 1, volume);

    Print(L"Exiting boot...\r\n");

    EFI_STATUS st_exit = exit_boot(image_handle);
    if (EFI_ERROR(st_exit)) {
        Print(L"ExitBootServices failed: %r\r\n", st_exit);
        return st_exit;
    }

    typedef void (*kentry_t)(uefi_data);
    kentry_t kentry = (kentry_t)(UINTN)0x100000;
    kentry(uefi_dt);

    return EFI_SUCCESS;
}

